# 通过主权 zk-rollups 实现快速终结

加密领域存在一个广泛的误解，即 zk-rollups 的最终确定时间很长。在这篇文章中，我们将解释为什么第一代 zk-rollups 需要这么长时间才能完成，以及如何在不牺牲安全性的情况下实现更低的延迟。

通过解决这个问题，我们将激发主权 zk-rollups 的设计。然后，我们将简要探讨主权设计提供的其他优势。


## 最终性瓶颈……以及如何解决它们

对于大多数 zk-rollups 来说，最大的开支之一是证明验证。根据底层的证明系统，以太坊上的汇总可能会花费 300k 到 5m 的 Gas 来验证单个证明。但由于证明大小随交易数量增长非常缓慢（或根本不增长），因此汇总可以通过在提交证明之前等待累积大量交易来降低每笔交易的成本。事实上，这正是当今大多数 zk-rollups 所做的事情；像 StarkEx 这样的流行汇总通常每隔几个小时才向 L1 发布一次证明。

但是，等待几个小时才能完成交易是一种令人无法接受的糟糕的用户体验。我们可以做得更好吗？如果汇总将原始交易数据发布到其 DA 层（而不是状态差异），那么想要快速确定性的高级用户就可以运行完整节点。但如果汇总使用状态差异，那么即使运行全节点也无济于事。这就是为什么今天大多数 zk-rollups 的排序器都会给出“软确认”。但软确认只能在具有集中式排序器的系统中实现。所以问题仍然存在 - 我们如何使去中心化的 zk-rollup 在延迟方面具有竞争力？

如果我们只关心降低全节点的延迟，那么将原始交易数据发布到链上就可以解决问题。只要完整的交易数据可用，全节点就可以像应用交易一样快速完成（假设 DA 层具有单时隙最终性）。这让我们的 zk-rollup 与传统的 L1 一样具有响应能力！

这是一个非常有力的结果。它使 zk-rollups 适用于对延迟高度敏感的应用程序，例如链上订单簿。尽管如此，它并没有完全解决最初的问题。我们真正想要的是减少轻客户端的延迟。我们可以在不大幅增加证明验证成本的情况下做到这一点吗？

令人惊讶的是，答案仍然是肯定的！方法如下：我们可以实时创建证明，然后使用递归将它们聚合成批量证明，而不是等待创建单个批量证明。只要我们立即通过 p2p 网络分发增量证明，轻客户端就会体验到快速的最终确定性。而且由于我们仍然只是在链上发布较慢的批次证明，因此我们不必为链上验证支付额外费用。换句话说，我们仍然得到了与 L1 的信任最小化桥 - 但该桥不再是轻客户端的真相来源。恭喜，我们刚刚构建了一个主权汇总！

## 证明分叉选择

眼尖的读者会注意到上一段中描述的系统存在问题。在今天的 rollups 中，L1 智能合约负责执行 rollups 分叉选择规则。换句话说，智能合约不仅仅验证 zk 证明，它还检查该证明是否建立在之前的证明（而不是其他分叉）的基础上，并且它处理了所有相关的“强制交易”在 L1 上发送。那么，如果我们不使用智能合约，我们如何选择规范的分叉呢？

答案再次出人意料地简单——如果我们要求将证明作为 calldata 发布在 L1 上，那么我们可以添加一条规则，即新证明仅在建立在先前有效证明的基础上才有效。尽管我们可以在客户端强制执行此规则，但这将要求用户扫描链的历史一直追溯到创世（或至少是一些众所周知的检查点） - 这并不理想。

值得庆幸的是，将其直接添加到 zk-proof 中并不太难。通过将 calldata 绑定回 L1 区块头，我们可以添加一条语句，表示“我已经扫描了 DA 层的证明（从区块 X 开始，到区块 Y 结束），并且该证明建立在最新的有效证明之上”。这让我们可以直接证明分叉选择规则，而不是在客户端强制执行！如果我们已经在扫描 DA 层以获取证据，那么我们也可以轻松扫描强制交易。

## 可移植性和互操作性

在智能合约汇总范例中，L1 桥是独一无二的。由于桥负责检查未包含在证明中的语句（诸如“此证明包括所有强制交易”之类的语句），因此将基于证明的桥添加到其他目的地通常没有意义。但是一旦我们将所有逻辑转移到证明中，这就不再是问题了。我们可以在任何我们想要的地方添加桥梁！

我们甚至可以更进一步。如果我们的 L1 智能合约只是一个普通的桥梁，我们可以完全废除它。第一次，考虑在不支持智能合约的系统上构建汇总是有意义的。只需采用现有的汇总逻辑并删除 L1 桥即可。突然之间，您可以部署在任何 DA 层上！换句话说，您的汇总逻辑可以立即在不同的 L1 之间移植。

##  结论

Rollups 的未来是主权的。通过直接证明其分叉选择规则，主权 zk-rollups 可实现无缝互操作性、即时可移植性和快速最终确定性。就像智能合约汇总一样，它们提供较低的 Gas 成本和信任最小化的桥梁 - 但它们不必被迫在成本和延迟之间进行权衡。有时，你可以鱼与熊掌兼得 🙂

一如既往，我们在 Sovereign 进行公开建设。我们所有的代码都是免费和开源的，欢迎贡献。哦，我们正在招聘。如果这听起来很有趣，那就来和我们一起构建吧！
