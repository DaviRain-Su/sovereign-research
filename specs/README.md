# Soveregin SDK specs

# 概述和核心 API

一个主权SDK链定义了一个逻辑区块链，它由三个不同的元素组合而成：

1, 一个L1区块链 - 提供数据可用性（DA）和共识

2, 一个状态转换函数（用Rust编写），它实现了一些在L1提供的数据上运行的“业务逻辑”

3, 一个能够（1）递归和（2）运行任意Rust代码的零知识证明系统


这些核心组件的所需功能可以在[Rollup接口规范](https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/rollup-interface/specs/interfaces)中找到。

从概念上讲，向主权SDK链添加一个区块需要经过三个步骤。首先，一个顺序器将新的数据块发布到L1链上。一旦该数据块在L1上完成，它就在逻辑上变得最终。在L1区块最终完成后，聚合层的全节点会扫描该区块，并按照它们出现的顺序处理所有相关的数据块，生成一个新的聚合状态根。此时，从所有全节点的角度来看，该区块在主观上已经最终完成。最后，证明节点（在zkVM内运行的全节点）执行与全节点几乎相同的过程——扫描DA区块并按顺序处理所有批次——生成证明并将其发布到链上。（如果聚合层希望激励证明者，证明需要发布到链上，否则无法确定哪个证明者首先处理了给定的批次）。一旦给定批次的证明被发布到链上，该批次对于包括轻客户端在内的所有节点来说就是主观上最终的。


主权SDK的工作原理基于三个主要步骤：

1. 首先，顺序器将新的数据块发布到L1链上。这个数据块包含了一系列的交易或者状态更新。一旦这个数据块在L1链上被确认，它就在逻辑上成为了最终的。这意味着，除非发生极端的情况（例如51%攻击），否则这个数据块不会被改变或者撤销。

2. 在L1区块最终完成后，聚合层的全节点会扫描这个区块，并按照它们出现的顺序处理所有相关的数据块，生成一个新的聚合状态根。聚合状态根是一个摘要，它代表了在处理这些数据块后的系统状态。在这个阶段，从所有全节点的角度来看，这个区块在主观上已经最终完成。也就是说，所有的全节点都认为这个区块是有效的，并且已经包含在了他们的本地副本中。

3. 最后，证明节点（在zkVM内运行的全节点）执行与全节点几乎相同的过程——扫描DA区块并按顺序处理所有批次——生成证明并将其发布到链上。这个证明是一个数学对象，它证明了证明节点正确地执行了所有的状态转换，并且得到了正确的聚合状态根。一旦给定批次的证明被发布到链上，该批次对于所有的节点（包括轻客户端）来说就是主观上最终的。

所以，Sovereign SDK的工作原理主要是通过这三个步骤来确保数据的一致性和可用性，同时利用零知识证明技术来提供额外的安全性保证。

![](https://github.com/Sovereign-Labs/sovereign-sdk/blob/nightly/rollup-interface/specs/assets/SovSDK.png)

## 词汇表

- DA链：数据可用性链的缩写。 Sovereign SDK rollup 底层的第 1 层区块链。
- Slot：数据可用性层中的一个“块”。可能包含许多批次的汇总交易。
- `Header` ：一个重载术语，可能指 (1) SDK 定义的逻辑链的块头，(2) 底层 L1（“数据可用性”）链的块头或 (3) 批次标头。
- 批量：一组 1 个或多个汇总交易，作为 DA 链上的单个数据 blob 提交。
- 批次`Header`：给定批次的摘要，与交易一起发布在 L1 上。汇总可以定义此标头以包含任何相关信息，但也可以选择完全省略它。
- JMT：Jellyfish Merkle Tree - Diem 发明的优化稀疏默克尔树，并在许多现代区块链中使用。
